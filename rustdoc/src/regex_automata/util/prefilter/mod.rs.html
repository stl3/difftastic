<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/regex-automata-0.3.7/src/util/prefilter/mod.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>mod.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><script defer src="../../../../main.js"></script><script defer src="../../../../source-script.js"></script><script defer src="../../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../../regex_automata/index.html"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
Defines a prefilter for accelerating regex searches.

A prefilter can be created by building a [`Prefilter`] value.

A prefilter represents one of the most important optimizations available for
accelerating regex searches. The idea of a prefilter is to very quickly find
candidate locations in a haystack where a regex _could_ match. Once a candidate
is found, it is then intended for the regex engine to run at that position to
determine whether the candidate is a match or a false positive.

In the aforementioned description of the prefilter optimization also lay its
demise. Namely, if a prefilter has a high false positive rate and it produces
lots of candidates, then a prefilter can overall make a regex search slower.
It can run more slowly because more time is spent ping-ponging between the
prefilter search and the regex engine attempting to confirm each candidate as
a match. This ping-ponging has overhead that adds up, and is exacerbated by
a high false positive rate.

Nevertheless, the optimization is still generally worth performing in most
cases. Particularly given just how much throughput can be improved. (It is not
uncommon for prefilter optimizations to improve throughput by one or two orders
of magnitude.)

Typically a prefilter is used to find occurrences of literal prefixes from a
regex pattern, but this isn&#39;t required. A prefilter can be used to look for
suffixes or even inner literals.

Note that as of now, prefilters throw away information about which pattern
each literal comes from. In other words, when a prefilter finds a match,
there&#39;s no way to know which pattern (or patterns) it came from. Therefore,
in order to confirm a match, you&#39;ll have to check all of the patterns by
running the full regex engine.
*/</span>

<span class="kw">mod</span> <span class="ident">aho_corasick</span>;
<span class="kw">mod</span> <span class="ident">byteset</span>;
<span class="kw">mod</span> <span class="ident">memchr</span>;
<span class="kw">mod</span> <span class="ident">memmem</span>;
<span class="kw">mod</span> <span class="ident">teddy</span>;

<span class="kw">use</span> <span class="ident">core</span>::{
    <span class="ident">borrow::Borrow</span>,
    <span class="ident">fmt::Debug</span>,
    <span class="ident">panic</span>::{<span class="ident">RefUnwindSafe</span>, <span class="ident">UnwindSafe</span>},
};

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">alloc::sync::Arc</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;syntax&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">regex_syntax::hir</span>::{<span class="ident">literal</span>, <span class="ident">Hir</span>};

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::search</span>::{<span class="ident">MatchKind</span>, <span class="ident">Span</span>};

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::prefilter</span>::{
    <span class="ident">aho_corasick::AhoCorasick</span>,
    <span class="ident">byteset::ByteSet</span>,
    <span class="ident">memchr</span>::{<span class="ident">Memchr</span>, <span class="ident">Memchr2</span>, <span class="ident">Memchr3</span>},
    <span class="ident">memmem::Memmem</span>,
    <span class="ident">teddy::Teddy</span>,
};

<span class="doccomment">/// A prefilter for accelerating regex searches.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If you already have your literals that you want to search with,</span>
<span class="doccomment">/// then the vanilla [`Prefilter::new`] constructor is for you. But</span>
<span class="doccomment">/// if you have an [`Hir`] value from the `regex-syntax` crate, then</span>
<span class="doccomment">/// [`Prefilter::from_hir_prefix`] might be more convenient. Namely, it uses</span>
<span class="doccomment">/// the [`regex-syntax::hir::literal`](regex_syntax::hir::literal) module to</span>
<span class="doccomment">/// extract literal prefixes for you, optimize them and then select and build a</span>
<span class="doccomment">/// prefilter matcher.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// A prefilter must have **zero false negatives**. However, by its very</span>
<span class="doccomment">/// nature, it may produce false positives. That is, a prefilter will never</span>
<span class="doccomment">/// skip over a position in the haystack that corresponds to a match of the</span>
<span class="doccomment">/// original regex pattern, but it *may* produce a match for a position</span>
<span class="doccomment">/// in the haystack that does *not* correspond to a match of the original</span>
<span class="doccomment">/// regex pattern. If you use either the [`Prefilter::from_hir_prefix`] or</span>
<span class="doccomment">/// [`Prefilter::from_hirs_prefix`] constructors, then this guarantee is</span>
<span class="doccomment">/// upheld for you automatically. This guarantee is not preserved if you use</span>
<span class="doccomment">/// [`Prefilter::new`] though, since it is up to the caller to provide correct</span>
<span class="doccomment">/// literal strings with respect to the original regex pattern.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Cloning</span>
<span class="doccomment">///</span>
<span class="doccomment">/// It is an API guarantee that cloning a prefilter is cheap. That is, cloning</span>
<span class="doccomment">/// it will not duplicate whatever heap memory is used to represent the</span>
<span class="doccomment">/// underlying matcher.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This example shows how to attach a `Prefilter` to the</span>
<span class="doccomment">/// [`PikeVM`](crate::nfa::thompson::pikevm::PikeVM) in order to accelerate</span>
<span class="doccomment">/// searches.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// use regex_automata::{</span>
<span class="doccomment">///     nfa::thompson::pikevm::PikeVM,</span>
<span class="doccomment">///     util::prefilter::Prefilter,</span>
<span class="doccomment">///     Match, MatchKind,</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &amp;[&quot;Bruce &quot;])</span>
<span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
<span class="doccomment">/// let re = PikeVM::builder()</span>
<span class="doccomment">///     .configure(PikeVM::config().prefilter(Some(pre)))</span>
<span class="doccomment">///     .build(r&quot;Bruce \w+&quot;)?;</span>
<span class="doccomment">/// let mut cache = re.create_cache();</span>
<span class="doccomment">/// assert_eq!(</span>
<span class="doccomment">///     Some(Match::must(0, 6..23)),</span>
<span class="doccomment">///     re.find(&amp;mut cache, &quot;Hello Bruce Springsteen!&quot;),</span>
<span class="doccomment">/// );</span>
<span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// But note that if you get your prefilter incorrect, it could lead to an</span>
<span class="doccomment">/// incorrect result!</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// use regex_automata::{</span>
<span class="doccomment">///     nfa::thompson::pikevm::PikeVM,</span>
<span class="doccomment">///     util::prefilter::Prefilter,</span>
<span class="doccomment">///     Match, MatchKind,</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // This prefilter is wrong!</span>
<span class="doccomment">/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &amp;[&quot;Patti &quot;])</span>
<span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
<span class="doccomment">/// let re = PikeVM::builder()</span>
<span class="doccomment">///     .configure(PikeVM::config().prefilter(Some(pre)))</span>
<span class="doccomment">///     .build(r&quot;Bruce \w+&quot;)?;</span>
<span class="doccomment">/// let mut cache = re.create_cache();</span>
<span class="doccomment">/// // We find no match even though the regex does match.</span>
<span class="doccomment">/// assert_eq!(</span>
<span class="doccomment">///     None,</span>
<span class="doccomment">///     re.find(&amp;mut cache, &quot;Hello Bruce Springsteen!&quot;),</span>
<span class="doccomment">/// );</span>
<span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Prefilter</span> {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>))]</span>
    <span class="ident">_unused</span>: (),
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
    <span class="ident">pre</span>: <span class="ident">Arc</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">PrefilterI</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
    <span class="ident">is_fast</span>: <span class="ident">bool</span>,
}

<span class="kw">impl</span> <span class="ident">Prefilter</span> {
    <span class="doccomment">/// Create a new prefilter from a sequence of needles and a corresponding</span>
    <span class="doccomment">/// match semantics.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This may return `None` for a variety of reasons, for example, if</span>
    <span class="doccomment">/// a suitable prefilter could not be constructed. That might occur</span>
    <span class="doccomment">/// if they are unavailable (e.g., the `perf-literal-substring` and</span>
    <span class="doccomment">/// `perf-literal-multisubstring` features aren&#39;t enabled), or it might</span>
    <span class="doccomment">/// occur because of heuristics or other artifacts of how the prefilter</span>
    <span class="doccomment">/// works.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Note that if you have an [`Hir`] expression, it may be more convenient</span>
    <span class="doccomment">/// to use [`Prefilter::from_hir_prefix`]. It will automatically handle the</span>
    <span class="doccomment">/// task of extracting prefix literals for you.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Example</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This example shows how match semantics can impact the matching</span>
    <span class="doccomment">/// algorithm used by the prefilter. For this reason, it is important to</span>
    <span class="doccomment">/// ensure that the match semantics given here are consistent with the</span>
    <span class="doccomment">/// match semantics intended for the regular expression that the literals</span>
    <span class="doccomment">/// were extracted from.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use regex_automata::{</span>
    <span class="doccomment">///     util::{prefilter::Prefilter, syntax},</span>
    <span class="doccomment">///     MatchKind, Span,</span>
    <span class="doccomment">/// };</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let hay = &quot;Hello samwise&quot;;</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// // With leftmost-first, we find &#39;samwise&#39; here because it comes</span>
    <span class="doccomment">/// // before &#39;sam&#39; in the sequence we give it..</span>
    <span class="doccomment">/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &amp;[&quot;samwise&quot;, &quot;sam&quot;])</span>
    <span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
    <span class="doccomment">/// assert_eq!(</span>
    <span class="doccomment">///     Some(Span::from(6..13)),</span>
    <span class="doccomment">///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),</span>
    <span class="doccomment">/// );</span>
    <span class="doccomment">/// // Still with leftmost-first but with the literals reverse, now &#39;sam&#39;</span>
    <span class="doccomment">/// // will match instead!</span>
    <span class="doccomment">/// let pre = Prefilter::new(MatchKind::LeftmostFirst, &amp;[&quot;sam&quot;, &quot;samwise&quot;])</span>
    <span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
    <span class="doccomment">/// assert_eq!(</span>
    <span class="doccomment">///     Some(Span::from(6..9)),</span>
    <span class="doccomment">///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),</span>
    <span class="doccomment">/// );</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
    <span class="doccomment">/// ```</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="ident">B</span>: <span class="ident">AsRef</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span><span class="op">&gt;</span>(
        <span class="ident">kind</span>: <span class="ident">MatchKind</span>,
        <span class="ident">needles</span>: <span class="kw-2">&amp;</span>[<span class="ident">B</span>],
    ) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Prefilter</span><span class="op">&gt;</span> {
        <span class="ident">Choice::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>).<span class="ident">and_then</span>(<span class="ident">Prefilter::from_choice</span>)
    }

    <span class="doccomment">/// This turns a prefilter selection into a `Prefilter`. That is, in turns</span>
    <span class="doccomment">/// the enum given into a trait object.</span>
    <span class="kw">fn</span> <span class="ident">from_choice</span>(<span class="ident">choice</span>: <span class="ident">Choice</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Prefilter</span><span class="op">&gt;</span> {
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>))]</span>
        {
            <span class="prelude-val">None</span>
        }
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
        {
            <span class="kw">let</span> <span class="ident">pre</span>: <span class="ident">Arc</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">PrefilterI</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">choice</span> {
                <span class="ident">Choice::Memchr</span>(<span class="ident">p</span>) =&gt; <span class="ident">Arc::new</span>(<span class="ident">p</span>),
                <span class="ident">Choice::Memchr2</span>(<span class="ident">p</span>) =&gt; <span class="ident">Arc::new</span>(<span class="ident">p</span>),
                <span class="ident">Choice::Memchr3</span>(<span class="ident">p</span>) =&gt; <span class="ident">Arc::new</span>(<span class="ident">p</span>),
                <span class="ident">Choice::Memmem</span>(<span class="ident">p</span>) =&gt; <span class="ident">Arc::new</span>(<span class="ident">p</span>),
                <span class="ident">Choice::Teddy</span>(<span class="ident">p</span>) =&gt; <span class="ident">Arc::new</span>(<span class="ident">p</span>),
                <span class="ident">Choice::ByteSet</span>(<span class="ident">p</span>) =&gt; <span class="ident">Arc::new</span>(<span class="ident">p</span>),
                <span class="ident">Choice::AhoCorasick</span>(<span class="ident">p</span>) =&gt; <span class="ident">Arc::new</span>(<span class="ident">p</span>),
            };
            <span class="kw">let</span> <span class="ident">is_fast</span> <span class="op">=</span> <span class="ident">pre</span>.<span class="ident">is_fast</span>();
            <span class="prelude-val">Some</span>(<span class="ident">Prefilter</span> { <span class="ident">pre</span>, <span class="ident">is_fast</span> })
        }
    }

    <span class="doccomment">/// This attempts to extract prefixes from the given `Hir` expression for</span>
    <span class="doccomment">/// the given match semantics, and if possible, builds a prefilter for</span>
    <span class="doccomment">/// them.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Example</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This example shows how to build a prefilter directly from an [`Hir`]</span>
    <span class="doccomment">/// expression, and use to find an occurrence of a prefix from the regex</span>
    <span class="doccomment">/// pattern.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use regex_automata::{</span>
    <span class="doccomment">///     util::{prefilter::Prefilter, syntax},</span>
    <span class="doccomment">///     MatchKind, Span,</span>
    <span class="doccomment">/// };</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let hir = syntax::parse(r&quot;(Bruce|Patti) \w+&quot;)?;</span>
    <span class="doccomment">/// let pre = Prefilter::from_hir_prefix(MatchKind::LeftmostFirst, &amp;hir)</span>
    <span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
    <span class="doccomment">/// let hay = &quot;Hello Patti Scialfa!&quot;;</span>
    <span class="doccomment">/// assert_eq!(</span>
    <span class="doccomment">///     Some(Span::from(6..12)),</span>
    <span class="doccomment">///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),</span>
    <span class="doccomment">/// );</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
    <span class="doccomment">/// ```</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;syntax&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_hir_prefix</span>(<span class="ident">kind</span>: <span class="ident">MatchKind</span>, <span class="ident">hir</span>: <span class="kw-2">&amp;</span><span class="ident">Hir</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Prefilter</span><span class="op">&gt;</span> {
        <span class="ident">Prefilter::from_hirs_prefix</span>(<span class="ident">kind</span>, <span class="kw-2">&amp;</span>[<span class="ident">hir</span>])
    }

    <span class="doccomment">/// This attempts to extract prefixes from the given `Hir` expressions for</span>
    <span class="doccomment">/// the given match semantics, and if possible, builds a prefilter for</span>
    <span class="doccomment">/// them.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Note that as of now, prefilters throw away information about which</span>
    <span class="doccomment">/// pattern each literal comes from. In other words, when a prefilter finds</span>
    <span class="doccomment">/// a match, there&#39;s no way to know which pattern (or patterns) it came</span>
    <span class="doccomment">/// from. Therefore, in order to confirm a match, you&#39;ll have to check all</span>
    <span class="doccomment">/// of the patterns by running the full regex engine.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Example</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This example shows how to build a prefilter directly from multiple</span>
    <span class="doccomment">/// `Hir` expressions expression, and use it to find an occurrence of a</span>
    <span class="doccomment">/// prefix from the regex patterns.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use regex_automata::{</span>
    <span class="doccomment">///     util::{prefilter::Prefilter, syntax},</span>
    <span class="doccomment">///     MatchKind, Span,</span>
    <span class="doccomment">/// };</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let hirs = syntax::parse_many(&amp;[</span>
    <span class="doccomment">///     r&quot;(Bruce|Patti) \w+&quot;,</span>
    <span class="doccomment">///     r&quot;Mrs?\. Doubtfire&quot;,</span>
    <span class="doccomment">/// ])?;</span>
    <span class="doccomment">/// let pre = Prefilter::from_hirs_prefix(MatchKind::LeftmostFirst, &amp;hirs)</span>
    <span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
    <span class="doccomment">/// let hay = &quot;Hello Mrs. Doubtfire&quot;;</span>
    <span class="doccomment">/// assert_eq!(</span>
    <span class="doccomment">///     Some(Span::from(6..20)),</span>
    <span class="doccomment">///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),</span>
    <span class="doccomment">/// );</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
    <span class="doccomment">/// ```</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;syntax&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_hirs_prefix</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="ident">Borrow</span><span class="op">&lt;</span><span class="ident">Hir</span><span class="op">&gt;</span><span class="op">&gt;</span>(
        <span class="ident">kind</span>: <span class="ident">MatchKind</span>,
        <span class="ident">hirs</span>: <span class="kw-2">&amp;</span>[<span class="ident">H</span>],
    ) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Prefilter</span><span class="op">&gt;</span> {
        <span class="ident">prefixes</span>(<span class="ident">kind</span>, <span class="ident">hirs</span>)
            .<span class="ident">literals</span>()
            .<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">lits</span><span class="op">|</span> <span class="ident">Prefilter::new</span>(<span class="ident">kind</span>, <span class="ident">lits</span>))
    }

    <span class="doccomment">/// Run this prefilter on `haystack[span.start..end]` and return a matching</span>
    <span class="doccomment">/// span if one exists.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The span returned is guaranteed to have a start position greater than</span>
    <span class="doccomment">/// or equal to the one given, and an end position less than or equal to</span>
    <span class="doccomment">/// the one given.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Example</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This example shows how to build a prefilter directly from an [`Hir`]</span>
    <span class="doccomment">/// expression, and use it to find an occurrence of a prefix from the regex</span>
    <span class="doccomment">/// pattern.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use regex_automata::{</span>
    <span class="doccomment">///     util::{prefilter::Prefilter, syntax},</span>
    <span class="doccomment">///     MatchKind, Span,</span>
    <span class="doccomment">/// };</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let hir = syntax::parse(r&quot;Bruce \w+&quot;)?;</span>
    <span class="doccomment">/// let pre = Prefilter::from_hir_prefix(MatchKind::LeftmostFirst, &amp;hir)</span>
    <span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
    <span class="doccomment">/// let hay = &quot;Hello Bruce Springsteen!&quot;;</span>
    <span class="doccomment">/// assert_eq!(</span>
    <span class="doccomment">///     Some(Span::from(6..12)),</span>
    <span class="doccomment">///     pre.find(hay.as_bytes(), Span::from(0..hay.len())),</span>
    <span class="doccomment">/// );</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
    <span class="doccomment">/// ```</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">find</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">haystack</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">span</span>: <span class="ident">Span</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span> {
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>))]</span>
        {
            <span class="macro">unreachable!</span>()
        }
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">pre</span>.<span class="ident">find</span>(<span class="ident">haystack</span>, <span class="ident">span</span>)
        }
    }

    <span class="doccomment">/// Returns the span of a prefix of `haystack[span.start..span.end]` if</span>
    <span class="doccomment">/// the prefilter matches.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The span returned is guaranteed to have a start position equivalent to</span>
    <span class="doccomment">/// the one given, and an end position less than or equal to the one given.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Example</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This example shows how to build a prefilter directly from an [`Hir`]</span>
    <span class="doccomment">/// expression, and use it to find an occurrence of a prefix from the regex</span>
    <span class="doccomment">/// pattern that begins at the start of a haystack only.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```</span>
    <span class="doccomment">/// use regex_automata::{</span>
    <span class="doccomment">///     util::{prefilter::Prefilter, syntax},</span>
    <span class="doccomment">///     MatchKind, Span,</span>
    <span class="doccomment">/// };</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// let hir = syntax::parse(r&quot;Bruce \w+&quot;)?;</span>
    <span class="doccomment">/// let pre = Prefilter::from_hir_prefix(MatchKind::LeftmostFirst, &amp;hir)</span>
    <span class="doccomment">///     .expect(&quot;a prefilter&quot;);</span>
    <span class="doccomment">/// let hay = &quot;Hello Bruce Springsteen!&quot;;</span>
    <span class="doccomment">/// // Nothing is found here because &#39;Bruce&#39; does</span>
    <span class="doccomment">/// // not occur at the beginning of our search.</span>
    <span class="doccomment">/// assert_eq!(</span>
    <span class="doccomment">///     None,</span>
    <span class="doccomment">///     pre.prefix(hay.as_bytes(), Span::from(0..hay.len())),</span>
    <span class="doccomment">/// );</span>
    <span class="doccomment">/// // But if we change where we start the search</span>
    <span class="doccomment">/// // to begin where &#39;Bruce &#39; begins, then a</span>
    <span class="doccomment">/// // match will be found.</span>
    <span class="doccomment">/// assert_eq!(</span>
    <span class="doccomment">///     Some(Span::from(6..12)),</span>
    <span class="doccomment">///     pre.prefix(hay.as_bytes(), Span::from(6..hay.len())),</span>
    <span class="doccomment">/// );</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
    <span class="doccomment">/// ```</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">prefix</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">haystack</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">span</span>: <span class="ident">Span</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span> {
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>))]</span>
        {
            <span class="macro">unreachable!</span>()
        }
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">pre</span>.<span class="ident">prefix</span>(<span class="ident">haystack</span>, <span class="ident">span</span>)
        }
    }

    <span class="doccomment">/// Returns the heap memory, in bytes, used by the underlying prefilter.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">memory_usage</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>))]</span>
        {
            <span class="macro">unreachable!</span>()
        }
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">pre</span>.<span class="ident">memory_usage</span>()
        }
    }

    <span class="doccomment">/// Implementations might return true here if they believe themselves to</span>
    <span class="doccomment">/// be &quot;fast.&quot; The concept of &quot;fast&quot; is deliberately left vague, but in</span>
    <span class="doccomment">/// practice this usually corresponds to whether it&#39;s believed that SIMD</span>
    <span class="doccomment">/// will be used.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Why do we care about this? Well, some prefilter tricks tend to come</span>
    <span class="doccomment">/// with their own bits of overhead, and so might only make sense if we</span>
    <span class="doccomment">/// know that a scan will be *much* faster than the regex engine itself.</span>
    <span class="doccomment">/// Otherwise, the trick may not be worth doing. Whether something is</span>
    <span class="doccomment">/// &quot;much&quot; faster than the regex engine generally boils down to whether</span>
    <span class="doccomment">/// SIMD is used. (But not always. Even a SIMD matcher with a high false</span>
    <span class="doccomment">/// positive rate can become quite slow.)</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Even if this returns true, it is still possible for the prefilter to</span>
    <span class="doccomment">/// be &quot;slow.&quot; Remember, prefilters are just heuristics. We can&#39;t really</span>
    <span class="doccomment">/// *know* a prefilter will be fast without actually trying the prefilter.</span>
    <span class="doccomment">/// (Which of course we cannot afford to do.)</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">is_fast</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>))]</span>
        {
            <span class="macro">unreachable!</span>()
        }
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">is_fast</span>
        }
    }
}

<span class="doccomment">/// A trait for abstracting over prefilters. Basically, a prefilter is</span>
<span class="doccomment">/// something that do an unanchored *and* an anchored search in a haystack</span>
<span class="doccomment">/// within a given span.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This exists pretty much only so that we can use prefilters as a trait</span>
<span class="doccomment">/// object (which is what `Prefilter` is). If we ever move off of trait objects</span>
<span class="doccomment">/// and to an enum, then it&#39;s likely this trait could be removed.</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">trait</span> <span class="ident">PrefilterI</span>:
    <span class="ident">Debug</span> <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span> <span class="op">+</span> <span class="ident">RefUnwindSafe</span> <span class="op">+</span> <span class="ident">UnwindSafe</span> <span class="op">+</span> <span class="lifetime">&#39;static</span>
{
    <span class="doccomment">/// Run this prefilter on `haystack[span.start..end]` and return a matching</span>
    <span class="doccomment">/// span if one exists.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The span returned is guaranteed to have a start position greater than</span>
    <span class="doccomment">/// or equal to the one given, and an end position less than or equal to</span>
    <span class="doccomment">/// the one given.</span>
    <span class="kw">fn</span> <span class="ident">find</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">haystack</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">span</span>: <span class="ident">Span</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Returns the span of a prefix of `haystack[span.start..span.end]` if</span>
    <span class="doccomment">/// the prefilter matches.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The span returned is guaranteed to have a start position equivalent to</span>
    <span class="doccomment">/// the one given, and an end position less than or equal to the one given.</span>
    <span class="kw">fn</span> <span class="ident">prefix</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">haystack</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">span</span>: <span class="ident">Span</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Returns the heap memory, in bytes, used by the underlying prefilter.</span>
    <span class="kw">fn</span> <span class="ident">memory_usage</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span>;

    <span class="doccomment">/// Implementations might return true here if they believe themselves to</span>
    <span class="doccomment">/// be &quot;fast.&quot; See [`Prefilter::is_fast`] for more details.</span>
    <span class="kw">fn</span> <span class="ident">is_fast</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span>;
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">P</span>: <span class="ident">PrefilterI</span> <span class="op">+</span> <span class="question-mark">?</span><span class="ident">Sized</span><span class="op">&gt;</span> <span class="ident">PrefilterI</span> <span class="kw">for</span> <span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">P</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;perf-inline&quot;</span>, <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
    <span class="kw">fn</span> <span class="ident">find</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">haystack</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">span</span>: <span class="ident">Span</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span> {
        (<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="kw-2">*</span><span class="self">self</span>).<span class="ident">find</span>(<span class="ident">haystack</span>, <span class="ident">span</span>)
    }

    <span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;perf-inline&quot;</span>, <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
    <span class="kw">fn</span> <span class="ident">prefix</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">haystack</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">span</span>: <span class="ident">Span</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span> {
        (<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="kw-2">*</span><span class="self">self</span>).<span class="ident">prefix</span>(<span class="ident">haystack</span>, <span class="ident">span</span>)
    }

    <span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;perf-inline&quot;</span>, <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
    <span class="kw">fn</span> <span class="ident">memory_usage</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
        (<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="kw-2">*</span><span class="self">self</span>).<span class="ident">memory_usage</span>()
    }

    <span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;perf-inline&quot;</span>, <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
    <span class="kw">fn</span> <span class="ident">is_fast</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        (<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="kw-2">*</span><span class="self">self</span>).<span class="ident">is_fast</span>()
    }
}

<span class="doccomment">/// A type that encapsulates the selection of a prefilter algorithm from a</span>
<span class="doccomment">/// sequence of needles.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The existence of this type is a little tricky, because we don&#39;t (currently)</span>
<span class="doccomment">/// use it for performing a search. Instead, we really only consume it by</span>
<span class="doccomment">/// converting the underlying prefilter into a trait object, whether that be</span>
<span class="doccomment">/// `dyn PrefilterI` or `dyn Strategy` (for the meta regex engine). In order</span>
<span class="doccomment">/// to avoid re-copying the prefilter selection logic, we isolate it here, and</span>
<span class="doccomment">/// then force anything downstream that wants to convert it to a trait object</span>
<span class="doccomment">/// to do trivial case analysis on it.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// One wonders whether we *should* use an enum instead of a trait object.</span>
<span class="doccomment">/// At time of writing, I chose trait objects based on instinct because 1) I</span>
<span class="doccomment">/// knew I wasn&#39;t going to inline anything and 2) there would potentially be</span>
<span class="doccomment">/// many different choices. However, as of time of writing, I haven&#39;t actually</span>
<span class="doccomment">/// compared the trait object approach to the enum approach. That probably</span>
<span class="doccomment">/// should be litigated, but I ran out of steam.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Note that if the `alloc` feature is disabled, then values of this type</span>
<span class="doccomment">/// are (and should) never be constructed. Also, in practice, for any of the</span>
<span class="doccomment">/// prefilters to be selected, you&#39;ll need at least one of the `perf-literal-*`</span>
<span class="doccomment">/// features enabled.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">enum</span> <span class="ident">Choice</span> {
    <span class="ident">Memchr</span>(<span class="ident">Memchr</span>),
    <span class="ident">Memchr2</span>(<span class="ident">Memchr2</span>),
    <span class="ident">Memchr3</span>(<span class="ident">Memchr3</span>),
    <span class="ident">Memmem</span>(<span class="ident">Memmem</span>),
    <span class="ident">Teddy</span>(<span class="ident">Teddy</span>),
    <span class="ident">ByteSet</span>(<span class="ident">ByteSet</span>),
    <span class="ident">AhoCorasick</span>(<span class="ident">AhoCorasick</span>),
}

<span class="kw">impl</span> <span class="ident">Choice</span> {
    <span class="doccomment">/// Select what is believed to be the best prefilter algorithm for the</span>
    <span class="doccomment">/// match semantics and sequence of needles given.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This selection algorithm uses the needles as given without any</span>
    <span class="doccomment">/// modification. For example, if `[bar]` is given, then this doesn&#39;t</span>
    <span class="doccomment">/// try to select `memchr` for `b`. Instead, it would select `memmem`</span>
    <span class="doccomment">/// for `bar`. If callers would want `memchr` selected for `[bar]`, then</span>
    <span class="doccomment">/// callers should massages the literals themselves. That is, callers are</span>
    <span class="doccomment">/// responsible for heuristics surrounding which sequence of literals is</span>
    <span class="doccomment">/// best.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// What this selection algorithm does is attempt to use the fastest</span>
    <span class="doccomment">/// prefilter that works for the literals given. So if `[a, b]`, is given,</span>
    <span class="doccomment">/// then `memchr2` is selected.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Of course, which prefilter is selected is also subject to what</span>
    <span class="doccomment">/// is available. For example, if `alloc` isn&#39;t enabled, then</span>
    <span class="doccomment">/// that limits which prefilters can be selected. Similarly, if</span>
    <span class="doccomment">/// `perf-literal-substring` isn&#39;t enabled, then nothing from the `memchr`</span>
    <span class="doccomment">/// crate can be returned.</span>
    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="ident">B</span>: <span class="ident">AsRef</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span><span class="op">&gt;</span>(
        <span class="ident">kind</span>: <span class="ident">MatchKind</span>,
        <span class="ident">needles</span>: <span class="kw-2">&amp;</span>[<span class="ident">B</span>],
    ) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Choice</span><span class="op">&gt;</span> {
        <span class="comment">// An empty set means the regex matches nothing, so no sense in</span>
        <span class="comment">// building a prefilter.</span>
        <span class="kw">if</span> <span class="ident">needles</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">0</span> {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter building failed: found empty set of literals&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">None</span>;
        }
        <span class="comment">// If the regex can match the empty string, then the prefilter</span>
        <span class="comment">// will by definition match at every position. This is obviously</span>
        <span class="comment">// completely ineffective.</span>
        <span class="kw">if</span> <span class="ident">needles</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="ident">n</span>.<span class="ident">as_ref</span>().<span class="ident">is_empty</span>()) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter building failed: literals match empty string&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">None</span>;
        }
        <span class="comment">// BREADCRUMBS: Perhaps the literal optimizer should special case</span>
        <span class="comment">// sequences of length two or three if the leading bytes of each are</span>
        <span class="comment">// &quot;rare&quot;? Or perhaps, if there are two or three total possible leading</span>
        <span class="comment">// bytes, regardless of the number of literals, and all are rare...</span>
        <span class="comment">// Then well, perhaps we should use memchr2 or memchr3 in those cases?</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">pre</span>) <span class="op">=</span> <span class="ident">Memchr::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter built: memchr&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="ident">Choice::Memchr</span>(<span class="ident">pre</span>));
        }
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">pre</span>) <span class="op">=</span> <span class="ident">Memchr2::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter built: memchr2&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="ident">Choice::Memchr2</span>(<span class="ident">pre</span>));
        }
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">pre</span>) <span class="op">=</span> <span class="ident">Memchr3::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter built: memchr3&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="ident">Choice::Memchr3</span>(<span class="ident">pre</span>));
        }
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">pre</span>) <span class="op">=</span> <span class="ident">Memmem::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter built: memmem&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="ident">Choice::Memmem</span>(<span class="ident">pre</span>));
        }
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">pre</span>) <span class="op">=</span> <span class="ident">Teddy::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter built: teddy&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="ident">Choice::Teddy</span>(<span class="ident">pre</span>));
        }
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">pre</span>) <span class="op">=</span> <span class="ident">ByteSet::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter built: byteset&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="ident">Choice::ByteSet</span>(<span class="ident">pre</span>));
        }
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">pre</span>) <span class="op">=</span> <span class="ident">AhoCorasick::new</span>(<span class="ident">kind</span>, <span class="ident">needles</span>) {
            <span class="macro">debug!</span>(<span class="string">&quot;prefilter built: aho-corasick&quot;</span>);
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="ident">Choice::AhoCorasick</span>(<span class="ident">pre</span>));
        }
        <span class="macro">debug!</span>(<span class="string">&quot;prefilter building failed: no strategy could be found&quot;</span>);
        <span class="prelude-val">None</span>
    }
}

<span class="doccomment">/// Extracts all of the prefix literals from the given HIR expressions into a</span>
<span class="doccomment">/// single `Seq`. The literals in the sequence are ordered with respect to the</span>
<span class="doccomment">/// order of the given HIR expressions and consistent with the match semantics</span>
<span class="doccomment">/// given.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The sequence returned is &quot;optimized.&quot; That is, they may be shrunk or even</span>
<span class="doccomment">/// truncated according to heuristics with the intent of making them more</span>
<span class="doccomment">/// useful as a prefilter. (Which translates to both using faster algorithms</span>
<span class="doccomment">/// and minimizing the false positive rate.)</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Note that this erases any connection between the literals and which pattern</span>
<span class="doccomment">/// (or patterns) they came from.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The match kind given must correspond to the match semantics of the regex</span>
<span class="doccomment">/// that is represented by the HIRs given. The match semantics may change the</span>
<span class="doccomment">/// literal sequence returned.</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;syntax&quot;</span>)]</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">prefixes</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span>(<span class="ident">kind</span>: <span class="ident">MatchKind</span>, <span class="ident">hirs</span>: <span class="kw-2">&amp;</span>[<span class="ident">H</span>]) -&gt; <span class="ident">literal::Seq</span>
<span class="kw">where</span>
    <span class="ident">H</span>: <span class="ident">core::borrow::Borrow</span><span class="op">&lt;</span><span class="ident">Hir</span><span class="op">&gt;</span>,
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">extractor</span> <span class="op">=</span> <span class="ident">literal::Extractor::new</span>();
    <span class="ident">extractor</span>.<span class="ident">kind</span>(<span class="ident">literal::ExtractKind::Prefix</span>);

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">prefixes</span> <span class="op">=</span> <span class="ident">literal::Seq::empty</span>();
    <span class="kw">for</span> <span class="ident">hir</span> <span class="kw">in</span> <span class="ident">hirs</span> {
        <span class="ident">prefixes</span>.<span class="ident">union</span>(<span class="kw-2">&amp;mut</span> <span class="ident">extractor</span>.<span class="ident">extract</span>(<span class="ident">hir</span>.<span class="ident">borrow</span>()));
    }
    <span class="macro">debug!</span>(
        <span class="string">&quot;prefixes (len={:?}, exact={:?}) extracted before optimization: {:?}&quot;</span>,
        <span class="ident">prefixes</span>.<span class="ident">len</span>(),
        <span class="ident">prefixes</span>.<span class="ident">is_exact</span>(),
        <span class="ident">prefixes</span>
    );
    <span class="kw">match</span> <span class="ident">kind</span> {
        <span class="ident">MatchKind::All</span> =&gt; {
            <span class="ident">prefixes</span>.<span class="ident">sort</span>();
            <span class="ident">prefixes</span>.<span class="ident">dedup</span>();
        }
        <span class="ident">MatchKind::LeftmostFirst</span> =&gt; {
            <span class="ident">prefixes</span>.<span class="ident">optimize_for_prefix_by_preference</span>();
        }
    }
    <span class="macro">debug!</span>(
        <span class="string">&quot;prefixes (len={:?}, exact={:?}) extracted after optimization: {:?}&quot;</span>,
        <span class="ident">prefixes</span>.<span class="ident">len</span>(),
        <span class="ident">prefixes</span>.<span class="ident">is_exact</span>(),
        <span class="ident">prefixes</span>
    );
    <span class="ident">prefixes</span>
}

<span class="doccomment">/// Like `prefixes`, but for all suffixes of all matches for the given HIRs.</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;syntax&quot;</span>)]</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">suffixes</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span>(<span class="ident">kind</span>: <span class="ident">MatchKind</span>, <span class="ident">hirs</span>: <span class="kw-2">&amp;</span>[<span class="ident">H</span>]) -&gt; <span class="ident">literal::Seq</span>
<span class="kw">where</span>
    <span class="ident">H</span>: <span class="ident">core::borrow::Borrow</span><span class="op">&lt;</span><span class="ident">Hir</span><span class="op">&gt;</span>,
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">extractor</span> <span class="op">=</span> <span class="ident">literal::Extractor::new</span>();
    <span class="ident">extractor</span>.<span class="ident">kind</span>(<span class="ident">literal::ExtractKind::Suffix</span>);

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">suffixes</span> <span class="op">=</span> <span class="ident">literal::Seq::empty</span>();
    <span class="kw">for</span> <span class="ident">hir</span> <span class="kw">in</span> <span class="ident">hirs</span> {
        <span class="ident">suffixes</span>.<span class="ident">union</span>(<span class="kw-2">&amp;mut</span> <span class="ident">extractor</span>.<span class="ident">extract</span>(<span class="ident">hir</span>.<span class="ident">borrow</span>()));
    }
    <span class="macro">debug!</span>(
        <span class="string">&quot;suffixes (len={:?}, exact={:?}) extracted before optimization: {:?}&quot;</span>,
        <span class="ident">suffixes</span>.<span class="ident">len</span>(),
        <span class="ident">suffixes</span>.<span class="ident">is_exact</span>(),
        <span class="ident">suffixes</span>
    );
    <span class="kw">match</span> <span class="ident">kind</span> {
        <span class="ident">MatchKind::All</span> =&gt; {
            <span class="ident">suffixes</span>.<span class="ident">sort</span>();
            <span class="ident">suffixes</span>.<span class="ident">dedup</span>();
        }
        <span class="ident">MatchKind::LeftmostFirst</span> =&gt; {
            <span class="ident">suffixes</span>.<span class="ident">optimize_for_suffix_by_preference</span>();
        }
    }
    <span class="macro">debug!</span>(
        <span class="string">&quot;suffixes (len={:?}, exact={:?}) extracted after optimization: {:?}&quot;</span>,
        <span class="ident">suffixes</span>.<span class="ident">len</span>(),
        <span class="ident">suffixes</span>.<span class="ident">is_exact</span>(),
        <span class="ident">suffixes</span>
    );
    <span class="ident">suffixes</span>
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="regex_automata" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>