<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A virtual machine for executing regex searches with capturing groups."><meta name="keywords" content="rust, rustlang, rust-lang, PikeVM"><title>PikeVM in regex_automata::nfa::thompson::pikevm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><script defer src="../../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">PikeVM</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.always_match">always_match</a></li><li><a href="#method.builder">builder</a></li><li><a href="#method.captures">captures</a></li><li><a href="#method.captures_iter">captures_iter</a></li><li><a href="#method.config">config</a></li><li><a href="#method.create_cache">create_cache</a></li><li><a href="#method.create_captures">create_captures</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.get_config">get_config</a></li><li><a href="#method.get_nfa">get_nfa</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.never_match">never_match</a></li><li><a href="#method.new">new</a></li><li><a href="#method.new_from_nfa">new_from_nfa</a></li><li><a href="#method.new_many">new_many</a></li><li><a href="#method.pattern_len">pattern_len</a></li><li><a href="#method.reset_cache">reset_cache</a></li><li><a href="#method.search">search</a></li><li><a href="#method.search_slots">search_slots</a></li><li><a href="#method.which_overlapping_matches">which_overlapping_matches</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-Debug">Debug</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In regex_automata::nfa::thompson::pikevm</a></h2><div id="sidebar-vars" data-name="PikeVM" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../../regex_automata/index.html"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../../../index.html">regex_automata</a>::<wbr><a href="../../index.html">nfa</a>::<wbr><a href="../index.html">thompson</a>::<wbr><a href="index.html">pikevm</a>::<wbr><a class="struct" href="#">PikeVM</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#387-390">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct PikeVM { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A virtual machine for executing regex searches with capturing groups.</p>
<h2 id="infallible-apis"><a href="#infallible-apis">Infallible APIs</a></h2>
<p>Unlike most other regex engines in this crate, a <code>PikeVM</code> never returns an
error at search time. It supports all <a href="../../../enum.Anchored.html" title="Anchored"><code>Anchored</code></a> configurations, never
quits and works on haystacks of arbitrary length.</p>
<p>There are two caveats to mention though:</p>
<ul>
<li>If an invalid pattern ID is given to a search via <a href="../../../enum.Anchored.html#variant.Pattern" title="Anchored::Pattern"><code>Anchored::Pattern</code></a>,
then the PikeVM will report “no match.” This is consistent with all other
regex engines in this crate.</li>
<li>When using <a href="struct.PikeVM.html#method.which_overlapping_matches" title="PikeVM::which_overlapping_matches"><code>PikeVM::which_overlapping_matches</code></a> with a <a href="../../../struct.PatternSet.html" title="PatternSet"><code>PatternSet</code></a>
that has insufficient capacity to store all valid pattern IDs, then if a
match occurs for a <code>PatternID</code> that cannot be inserted, it is silently
dropped as if it did not match.</li>
</ul>
<h2 id="advice"><a href="#advice">Advice</a></h2>
<p>The <code>PikeVM</code> is generally the most “powerful” regex engine in this crate.
“Powerful” in this context means that it can handle any regular expression
that is parseable by <code>regex-syntax</code> and any size haystack. Regretably,
the <code>PikeVM</code> is also simultaneously often the <em>slowest</em> regex engine in
practice. This results in an annoying situation where one generally tries
to pick any other regex engine (or perhaps none at all) before being
forced to fall back to a <code>PikeVM</code>.</p>
<p>For example, a common strategy for dealing with capturing groups is to
actually look for the overall match of the regex using a faster regex
engine, like a <a href="../../../hybrid/regex/struct.Regex.html">lazy DFA</a>. Once the overall
match is found, one can then run the <code>PikeVM</code> on just the match span to
find the spans of the capturing groups. In this way, the faster regex
engine does the majority of the work, while the <code>PikeVM</code> only lends its
power in a more limited role.</p>
<p>Unfortunately, this isn’t always possible because the faster regex engines
don’t support all of the regex features in <code>regex-syntax</code>. This notably
includes (and is currently limited to) Unicode word boundaries. So if
your pattern has Unicode word boundaries, you typically can’t use a
DFA-based regex engine at all (unless you <a href="../../../hybrid/dfa/struct.Config.html#method.unicode_word_boundary">enable heuristic support for
it</a>). (The <a href="../../../dfa/onepass/struct.DFA.html">one-pass
DFA</a> can handle Unicode word boundaries for
anchored searches only, but in a cruel sort of joke, many Unicode features
tend to result in making the regex <em>not</em> one-pass.)</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>This example shows that the <code>PikeVM</code> implements Unicode word boundaries
correctly by default.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">r&quot;\b\w+\b&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;Шерлок Холмс&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">12</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">13</span>..<span class="number">23</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">it</span>.<span class="ident">next</span>());</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#392-706">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#413-415">source</a></span><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given regular expression using the default configuration and
return the corresponding <code>PikeVM</code>.</p>
<p>If you want a non-default configuration, then use the <a href="struct.Builder.html" title="Builder"><code>Builder</code></a> to
set your own configuration.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">3</span>..<span class="number">14</span>)),
    <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;zzzfoo12345barzzz&quot;</span>).<span class="ident">next</span>(),
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new_many" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#439-443">source</a></span><a href="#method.new_many" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new_many" class="fnname">new_many</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.str.html">str</a>&gt;&gt;(patterns: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[P]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Like <code>new</code>, but parses multiple patterns into a single “multi regex.”
This similarly uses the default regex configuration.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new_many</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;[a-z]+&quot;</span>, <span class="string">&quot;[0-9]+&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;abc 1 foo 4567 0 quux&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">1</span>, <span class="number">4</span>..<span class="number">5</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">6</span>..<span class="number">9</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">1</span>, <span class="number">10</span>..<span class="number">14</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">1</span>, <span class="number">15</span>..<span class="number">16</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">17</span>..<span class="number">21</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">it</span>.<span class="ident">next</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new_from_nfa" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#475-477">source</a></span><a href="#method.new_from_nfa" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new_from_nfa" class="fnname">new_from_nfa</a>(nfa: <a class="struct" href="../struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Like <code>new</code>, but builds a PikeVM directly from an NFA. This is useful
if you already have an NFA, or even if you hand-assembled the NFA.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This shows how to hand assemble a regular expression via its HIR,
compile an NFA from it and build a PikeVM from the NFA.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson</span>::{<span class="ident">NFA</span>, <span class="ident">pikevm::PikeVM</span>}, <span class="ident">Match</span>};
<span class="kw">use</span> <span class="ident">regex_syntax::hir</span>::{<span class="ident">Hir</span>, <span class="ident">Class</span>, <span class="ident">ClassBytes</span>, <span class="ident">ClassBytesRange</span>};

<span class="kw">let</span> <span class="ident">hir</span> <span class="op">=</span> <span class="ident">Hir::class</span>(<span class="ident">Class::Bytes</span>(<span class="ident">ClassBytes::new</span>(<span class="macro">vec!</span>[
    <span class="ident">ClassBytesRange::new</span>(<span class="string">b&#39;0&#39;</span>, <span class="string">b&#39;9&#39;</span>),
    <span class="ident">ClassBytesRange::new</span>(<span class="string">b&#39;A&#39;</span>, <span class="string">b&#39;Z&#39;</span>),
    <span class="ident">ClassBytesRange::new</span>(<span class="string">b&#39;_&#39;</span>, <span class="string">b&#39;_&#39;</span>),
    <span class="ident">ClassBytesRange::new</span>(<span class="string">b&#39;a&#39;</span>, <span class="string">b&#39;z&#39;</span>),
])));

<span class="kw">let</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">NFA::config</span>().<span class="ident">nfa_size_limit</span>(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let</span> <span class="ident">nfa</span> <span class="op">=</span> <span class="ident">NFA::compiler</span>().<span class="ident">configure</span>(<span class="ident">config</span>).<span class="ident">build_from_hir</span>(<span class="kw-2">&amp;</span><span class="ident">hir</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new_from_nfa</span>(<span class="ident">nfa</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">cache</span>, <span class="kw-2">mut</span> <span class="ident">caps</span>) <span class="op">=</span> (<span class="ident">re</span>.<span class="ident">create_cache</span>(), <span class="ident">re</span>.<span class="ident">create_captures</span>());
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
<span class="ident">re</span>.<span class="ident">captures</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;!@#A#@!&quot;</span>, <span class="kw-2">&amp;mut</span> <span class="ident">caps</span>);
<span class="macro">assert_eq!</span>(<span class="ident">expected</span>, <span class="ident">caps</span>.<span class="ident">get_match</span>());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.always_match" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#494-497">source</a></span><a href="#method.always_match" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.always_match" class="fnname">always_match</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>PikeVM</code> that matches every input.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::always_match</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">expected</span>), <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;&quot;</span>).<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">expected</span>), <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">next</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.never_match" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#513-516">source</a></span><a href="#method.never_match" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.never_match" class="fnname">never_match</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a>, <a class="struct" href="../struct.BuildError.html" title="struct regex_automata::nfa::thompson::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>PikeVM</code> that never matches any input.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata::nfa::thompson::pikevm::PikeVM</span>;

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::never_match</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;&quot;</span>).<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;foo&quot;</span>).<span class="ident">next</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.config" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#552-554">source</a></span><a href="#method.config" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.config" class="fnname">config</a>() -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::nfa::thompson::pikevm::Config">Config</a></h4></section></summary><div class="docblock"><p>Return a default configuration for a <code>PikeVM</code>.</p>
<p>This is a convenience routine to avoid needing to import the <code>Config</code>
type when customizing the construction of a <code>PikeVM</code>.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>This example shows how to disable UTF-8 mode. When UTF-8 mode is
disabled, zero-width matches that split a codepoint are allowed.
Otherwise they are never reported.</p>
<p>In the code below, notice that <code>&quot;&quot;</code> is permitted to match positions
that split the encoding of a codepoint.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson</span>::{<span class="self">self</span>, <span class="ident">pikevm::PikeVM</span>}, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::builder</span>()
    .<span class="ident">thompson</span>(<span class="ident">thompson::Config::new</span>().<span class="ident">utf8</span>(<span class="bool-val">false</span>))
    .<span class="ident">build</span>(<span class="string">r&quot;&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="kw">let</span> <span class="ident">haystack</span> <span class="op">=</span> <span class="string">&quot;a☃z&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="ident">haystack</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">0</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">1</span>..<span class="number">1</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">2</span>..<span class="number">2</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">3</span>..<span class="number">3</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">4</span>..<span class="number">4</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">5</span>..<span class="number">5</span>)), <span class="ident">it</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">it</span>.<span class="ident">next</span>());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.builder" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#586-588">source</a></span><a href="#method.builder" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.builder" class="fnname">builder</a>() -&gt; <a class="struct" href="struct.Builder.html" title="struct regex_automata::nfa::thompson::pikevm::Builder">Builder</a></h4></section></summary><div class="docblock"><p>Return a builder for configuring the construction of a <code>PikeVM</code>.</p>
<p>This is a convenience routine to avoid needing to import the
<a href="struct.Builder.html" title="Builder"><code>Builder</code></a> type in common cases.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<p>This example shows how to use the builder to disable UTF-8 mode
everywhere.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{
    <span class="ident">nfa::thompson</span>::{<span class="self">self</span>, <span class="ident">pikevm::PikeVM</span>},
    <span class="ident">util::syntax</span>,
    <span class="ident">Match</span>,
};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::builder</span>()
    .<span class="ident">syntax</span>(<span class="ident">syntax::Config::new</span>().<span class="ident">utf8</span>(<span class="bool-val">false</span>))
    .<span class="ident">thompson</span>(<span class="ident">thompson::Config::new</span>().<span class="ident">utf8</span>(<span class="bool-val">false</span>))
    .<span class="ident">build</span>(<span class="string">r&quot;foo(?-u:[^b])ar.*&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">cache</span>, <span class="kw-2">mut</span> <span class="ident">caps</span>) <span class="op">=</span> (<span class="ident">re</span>.<span class="ident">create_cache</span>(), <span class="ident">re</span>.<span class="ident">create_captures</span>());

<span class="kw">let</span> <span class="ident">haystack</span> <span class="op">=</span> <span class="string">b&quot;\xFEfoo\xFFarzz\xE2\x98\xFF\n&quot;</span>;
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">1</span>..<span class="number">9</span>));
<span class="ident">re</span>.<span class="ident">captures</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="ident">haystack</span>, <span class="kw-2">&amp;mut</span> <span class="ident">caps</span>);
<span class="macro">assert_eq!</span>(<span class="ident">expected</span>, <span class="ident">caps</span>.<span class="ident">get_match</span>());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_captures" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#600-602">source</a></span><a href="#method.create_captures" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.create_captures" class="fnname">create_captures</a>(&amp;self) -&gt; <a class="struct" href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures">Captures</a></h4></section></summary><div class="docblock"><p>Create a new empty set of capturing groups that is guaranteed to be
valid for the search APIs on this <code>PikeVM</code>.</p>
<p>A <code>Captures</code> value created for a specific <code>PikeVM</code> cannot be used with
any other <code>PikeVM</code>.</p>
<p>This is a convenience function for <a href="../../../util/captures/struct.Captures.html#method.all" title="Captures::all"><code>Captures::all</code></a>. See the
<a href="../../../util/captures/struct.Captures.html" title="Captures"><code>Captures</code></a> documentation for an explanation of its alternative
constructors that permit the <code>PikeVM</code> to do less work during a search,
and thus might make it faster.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_cache" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#610-612">source</a></span><a href="#method.create_cache" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.create_cache" class="fnname">create_cache</a>(&amp;self) -&gt; <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a></h4></section></summary><div class="docblock"><p>Create a new cache for this <code>PikeVM</code>.</p>
<p>The cache returned should only be used for searches for this
<code>PikeVM</code>. If you want to reuse the cache for another <code>PikeVM</code>, then
you must call <a href="struct.Cache.html#method.reset" title="Cache::reset"><code>Cache::reset</code></a> with that <code>PikeVM</code> (or, equivalently,
<a href="struct.PikeVM.html#method.reset_cache" title="PikeVM::reset_cache"><code>PikeVM::reset_cache</code></a>).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reset_cache" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#651-653">source</a></span><a href="#method.reset_cache" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reset_cache" class="fnname">reset_cache</a>(&amp;self, cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>)</h4></section></summary><div class="docblock"><p>Reset the given cache such that it can be used for searching with the
this <code>PikeVM</code> (and only this <code>PikeVM</code>).</p>
<p>A cache reset permits reusing memory already allocated in this cache
with a different <code>PikeVM</code>.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<p>This shows how to re-purpose a cache for use with a different <code>PikeVM</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re1</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">r&quot;\w&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">re2</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">r&quot;\W&quot;</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re1</span>.<span class="ident">create_cache</span>();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">2</span>)),
    <span class="ident">re1</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;Δ&quot;</span>).<span class="ident">next</span>(),
);

<span class="comment">// Using &#39;cache&#39; with re2 is not allowed. It may result in panics or</span>
<span class="comment">// incorrect results. In order to re-purpose the cache, we must reset</span>
<span class="comment">// it with the PikeVM we&#39;d like to use it with.</span>
<span class="comment">//</span>
<span class="comment">// Similarly, after this reset, using the cache with &#39;re1&#39; is also not</span>
<span class="comment">// allowed.</span>
<span class="ident">re2</span>.<span class="ident">reset_cache</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>);
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)),
    <span class="ident">re2</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;☃&quot;</span>).<span class="ident">next</span>(),
);
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pattern_len" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#691-693">source</a></span><a href="#method.pattern_len" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.pattern_len" class="fnname">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns compiled into this <code>PikeVM</code>.</p>
<p>In the case of a <code>PikeVM</code> that contains no patterns, this returns <code>0</code>.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<p>This example shows the pattern length for a <code>PikeVM</code> that never
matches:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata::nfa::thompson::pikevm::PikeVM</span>;

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::never_match</span>()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="ident">re</span>.<span class="ident">pattern_len</span>(), <span class="number">0</span>);</code></pre></div>
<p>And another example for a <code>PikeVM</code> that matches at every position:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata::nfa::thompson::pikevm::PikeVM</span>;

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::always_match</span>()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="ident">re</span>.<span class="ident">pattern_len</span>(), <span class="number">1</span>);</code></pre></div>
<p>And finally, a <code>PikeVM</code> that was constructed from multiple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata::nfa::thompson::pikevm::PikeVM</span>;

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new_many</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;[0-9]+&quot;</span>, <span class="string">&quot;[a-z]+&quot;</span>, <span class="string">&quot;[A-Z]+&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="ident">re</span>.<span class="ident">pattern_len</span>(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_config" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#697-699">source</a></span><a href="#method.get_config" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_config" class="fnname">get_config</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Config.html" title="struct regex_automata::nfa::thompson::pikevm::Config">Config</a></h4></section></summary><div class="docblock"><p>Return the config for this <code>PikeVM</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_nfa" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#703-705">source</a></span><a href="#method.get_nfa" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_nfa" class="fnname">get_nfa</a>(&amp;self) -&gt; &amp;<a class="struct" href="../struct.NFA.html" title="struct regex_automata::nfa::thompson::NFA">NFA</a></h4></section></summary><div class="docblock"><p>Returns a reference to the underlying NFA.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#708-941">source</a></span><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#767-774">source</a></span><a href="#method.is_match" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_match" class="fnname">is_match</a>&lt;'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;input: I<br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this <code>PikeVM</code> matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future
input will never lead to a different result. In particular, if the
underlying NFA enters a match state, then this routine will return
<code>true</code> immediately without inspecting any future input. (Consider how
this might make a difference given the regex <code>a+</code> on the haystack
<code>aaaaaaaaaaaaaaa</code>. This routine can stop after it sees the first <code>a</code>,
but routines like <code>find</code> need to continue searching because <code>+</code> is
greedy by default.)</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<p>This shows basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata::nfa::thompson::pikevm::PikeVM</span>;

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="macro">assert!</span>(<span class="ident">re</span>.<span class="ident">is_match</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;foo12345bar&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">re</span>.<span class="ident">is_match</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;foobar&quot;</span>));</code></pre></div>
<h5 id="example-consistency-with-search-apis"><a href="#example-consistency-with-search-apis">Example: consistency with search APIs</a></h5>
<p><code>is_match</code> is guaranteed to return <code>true</code> whenever <code>find</code> returns a
match. This includes searches that are executed entirely within a
codepoint:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Input</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">&quot;a*&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">re</span>.<span class="ident">is_match</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="ident">Input::new</span>(<span class="string">&quot;☃&quot;</span>).<span class="ident">span</span>(<span class="number">1</span>..<span class="number">2</span>)));</code></pre></div>
<p>Notice that when UTF-8 mode is disabled, then the above reports a
match because the restriction against zero-width matches that split a
codepoint has been lifted:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson</span>::{<span class="ident">pikevm::PikeVM</span>, <span class="ident">NFA</span>}, <span class="ident">Input</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::builder</span>()
    .<span class="ident">thompson</span>(<span class="ident">NFA::config</span>().<span class="ident">utf8</span>(<span class="bool-val">false</span>))
    .<span class="ident">build</span>(<span class="string">&quot;a*&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="macro">assert!</span>(<span class="ident">re</span>.<span class="ident">is_match</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="ident">Input::new</span>(<span class="string">&quot;☃&quot;</span>).<span class="ident">span</span>(<span class="number">1</span>..<span class="number">2</span>)));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#815-835">source</a></span><a href="#method.find" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.find" class="fnname">find</a>&lt;'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;input: I<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../struct.Match.html" title="struct regex_automata::Match">Match</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and returns a <code>Match</code> if one exists.</p>
<p>This routine only includes the overall match span. To get access to the
individual spans of each capturing group, use <a href="struct.PikeVM.html#method.captures" title="PikeVM::captures"><code>PikeVM::captures</code></a>.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<p>Leftmost first match semantics corresponds to the match with the
smallest starting offset, but where the end offset is determined by
preferring earlier branches in the original regular expression. For
example, <code>Sam|Samwise</code> will match <code>Sam</code> in <code>Samwise</code>, but <code>Samwise|Sam</code>
will match <code>Samwise</code> in <code>Samwise</code>.</p>
<p>Generally speaking, the “leftmost first” match is how most backtracking
regular expressions tend to work. This is in contrast to POSIX-style
regular expressions that yield “leftmost longest” matches. Namely,
both <code>Sam|Samwise</code> and <code>Samwise|Sam</code> match <code>Samwise</code> when using
leftmost longest semantics. (This crate does not currently support
leftmost longest semantics.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">expected</span>), <span class="ident">re</span>.<span class="ident">find</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;foo12345&quot;</span>));

<span class="comment">// Even though a match is found after reading the first byte (`a`),</span>
<span class="comment">// the leftmost first match semantics demand that we find the earliest</span>
<span class="comment">// match that prefers earlier parts of the pattern over later parts.</span>
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">expected</span>), <span class="ident">re</span>.<span class="ident">find</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;abc&quot;</span>));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#859-866">source</a></span><a href="#method.captures" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.captures" class="fnname">captures</a>&lt;'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;input: I, <br>&nbsp;&nbsp;&nbsp;&nbsp;caps: &amp;mut <a class="struct" href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures">Captures</a><br>)</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and writes the spans of capturing
groups that participated in a match into the provided <a href="../../../util/captures/struct.Captures.html" title="Captures"><code>Captures</code></a>
value. If no match was found, then <a href="../../../util/captures/struct.Captures.html#method.is_match" title="Captures::is_match"><code>Captures::is_match</code></a> is guaranteed
to return <code>false</code>.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Span</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">r&quot;^([0-9]{4})-([0-9]{2})-([0-9]{2})$&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">cache</span>, <span class="kw-2">mut</span> <span class="ident">caps</span>) <span class="op">=</span> (<span class="ident">re</span>.<span class="ident">create_cache</span>(), <span class="ident">re</span>.<span class="ident">create_captures</span>());

<span class="ident">re</span>.<span class="ident">captures</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="string">&quot;2010-03-14&quot;</span>, <span class="kw-2">&amp;mut</span> <span class="ident">caps</span>);
<span class="macro">assert!</span>(<span class="ident">caps</span>.<span class="ident">is_match</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Span::from</span>(<span class="number">0</span>..<span class="number">4</span>)), <span class="ident">caps</span>.<span class="ident">get_group</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Span::from</span>(<span class="number">5</span>..<span class="number">7</span>)), <span class="ident">caps</span>.<span class="ident">get_group</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">Span::from</span>(<span class="number">8</span>..<span class="number">10</span>)), <span class="ident">caps</span>.<span class="ident">get_group</span>(<span class="number">3</span>));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#889-897">source</a></span><a href="#method.find_iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.find_iter" class="fnname">find_iter</a>&lt;'r, 'c, 'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'r self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;input: I<br>) -&gt; <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::nfa::thompson::pikevm::FindMatches">FindMatches</a>&lt;'r, 'c, 'h&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::nfa::thompson::pikevm::FindMatches">FindMatches</a>&lt;'r, 'c, 'h&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r, 'c, 'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::nfa::thompson::pikevm::FindMatches">FindMatches</a>&lt;'r, 'c, 'h&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../../../struct.Match.html" title="struct regex_automata::Match">Match</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping leftmost matches in the
given bytes. If no match exists, then the iterator yields no elements.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo1 foo12 foo123&quot;</span>;
<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Match</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">find_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="ident">text</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">matches</span>, <span class="macro">vec!</span>[
    <span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">4</span>),
    <span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">5</span>..<span class="number">10</span>),
    <span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">11</span>..<span class="number">17</span>),
]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#932-940">source</a></span><a href="#method.captures_iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.captures_iter" class="fnname">captures_iter</a>&lt;'r, 'c, 'h, I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'r self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;input: I<br>) -&gt; <a class="struct" href="struct.CapturesMatches.html" title="struct regex_automata::nfa::thompson::pikevm::CapturesMatches">CapturesMatches</a>&lt;'r, 'c, 'h&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.CapturesMatches.html" title="struct regex_automata::nfa::thompson::pikevm::CapturesMatches">CapturesMatches</a>&lt;'r, 'c, 'h&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r, 'c, 'h&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.CapturesMatches.html" title="struct regex_automata::nfa::thompson::pikevm::CapturesMatches">CapturesMatches</a>&lt;'r, 'c, 'h&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures">Captures</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping <code>Captures</code> values. If no
match exists, then the iterator yields no elements.</p>
<p>This yields the same matches as <a href="struct.PikeVM.html#method.find_iter" title="PikeVM::find_iter"><code>PikeVM::find_iter</code></a>, but it includes
the spans of all capturing groups that participate in each match.</p>
<p><strong>Tip:</strong> See <a href="../../../util/iter/struct.Searcher.html"><code>util::iter::Searcher</code></a> for
how to correctly iterate over all matches in a haystack while avoiding
the creation of a new <code>Captures</code> value for every match. (Which you are
forced to do with an <code>Iterator</code>.)</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Span</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">&quot;foo(?P&lt;numbers&gt;[0-9]+)&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo1 foo12 foo123&quot;</span>;
<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Span</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">re</span>
    .<span class="ident">captures_iter</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="ident">text</span>)
    <span class="comment">// The unwrap is OK since &#39;numbers&#39; matches if the pattern matches.</span>
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">caps</span><span class="op">|</span> <span class="ident">caps</span>.<span class="ident">get_group_by_name</span>(<span class="string">&quot;numbers&quot;</span>).<span class="ident">unwrap</span>())
    .<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">matches</span>, <span class="macro">vec!</span>[
    <span class="ident">Span::from</span>(<span class="number">3</span>..<span class="number">4</span>),
    <span class="ident">Span::from</span>(<span class="number">8</span>..<span class="number">10</span>),
    <span class="ident">Span::from</span>(<span class="number">14</span>..<span class="number">17</span>),
]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#943-1216">source</a></span><a href="#impl-2" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.search" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#1020-1029">source</a></span><a href="#method.search" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.search" class="fnname">search</a>(&amp;self, cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, input: &amp;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;, caps: &amp;mut <a class="struct" href="../../../util/captures/struct.Captures.html" title="struct regex_automata::util::captures::Captures">Captures</a>)</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and writes the spans of capturing
groups that participated in a match into the provided <a href="../../../util/captures/struct.Captures.html" title="Captures"><code>Captures</code></a>
value. If no match was found, then <a href="../../../util/captures/struct.Captures.html#method.is_match" title="Captures::is_match"><code>Captures::is_match</code></a> is guaranteed
to return <code>false</code>.</p>
<p>This is like <a href="struct.PikeVM.html#method.captures" title="PikeVM::captures"><code>PikeVM::captures</code></a>, but it accepts a concrete <code>&amp;Input</code>
instead of an <code>Into&lt;Input&gt;</code>.</p>
<h5 id="example-specific-pattern-search"><a href="#example-specific-pattern-search">Example: specific pattern search</a></h5>
<p>This example shows how to build a multi-PikeVM that permits searching
for specific patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{
    <span class="ident">nfa::thompson::pikevm::PikeVM</span>,
    <span class="ident">Anchored</span>, <span class="ident">Match</span>, <span class="ident">PatternID</span>, <span class="ident">Input</span>,
};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new_many</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;[a-z0-9]{6}&quot;</span>, <span class="string">&quot;[a-z][a-z0-9]{5}&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">cache</span>, <span class="kw-2">mut</span> <span class="ident">caps</span>) <span class="op">=</span> (<span class="ident">re</span>.<span class="ident">create_cache</span>(), <span class="ident">re</span>.<span class="ident">create_captures</span>());
<span class="kw">let</span> <span class="ident">haystack</span> <span class="op">=</span> <span class="string">&quot;foo123&quot;</span>;

<span class="comment">// Since we are using the default leftmost-first match and both</span>
<span class="comment">// patterns match at the same starting position, only the first pattern</span>
<span class="comment">// will be returned in this case when doing a search for any of the</span>
<span class="comment">// patterns.</span>
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">6</span>));
<span class="ident">re</span>.<span class="ident">search</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="kw-2">&amp;</span><span class="ident">Input::new</span>(<span class="ident">haystack</span>), <span class="kw-2">&amp;mut</span> <span class="ident">caps</span>);
<span class="macro">assert_eq!</span>(<span class="ident">expected</span>, <span class="ident">caps</span>.<span class="ident">get_match</span>());

<span class="comment">// But if we want to check whether some other pattern matches, then we</span>
<span class="comment">// can provide its pattern ID.</span>
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">1</span>, <span class="number">0</span>..<span class="number">6</span>));
<span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="ident">Input::new</span>(<span class="ident">haystack</span>)
    .<span class="ident">anchored</span>(<span class="ident">Anchored::Pattern</span>(<span class="ident">PatternID::must</span>(<span class="number">1</span>)));
<span class="ident">re</span>.<span class="ident">search</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="kw-2">&amp;</span><span class="ident">input</span>, <span class="kw-2">&amp;mut</span> <span class="ident">caps</span>);
<span class="macro">assert_eq!</span>(<span class="ident">expected</span>, <span class="ident">caps</span>.<span class="ident">get_match</span>());
</code></pre></div>
<h5 id="example-specifying-the-bounds-of-a-search"><a href="#example-specifying-the-bounds-of-a-search">Example: specifying the bounds of a search</a></h5>
<p>This example shows how providing the bounds of a search can produce
different results than simply sub-slicing the haystack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">Match</span>, <span class="ident">Input</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new</span>(<span class="string">r&quot;\b[0-9]{3}\b&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">cache</span>, <span class="kw-2">mut</span> <span class="ident">caps</span>) <span class="op">=</span> (<span class="ident">re</span>.<span class="ident">create_cache</span>(), <span class="ident">re</span>.<span class="ident">create_captures</span>());
<span class="kw">let</span> <span class="ident">haystack</span> <span class="op">=</span> <span class="string">&quot;foo123bar&quot;</span>;

<span class="comment">// Since we sub-slice the haystack, the search doesn&#39;t know about</span>
<span class="comment">// the larger context and assumes that `123` is surrounded by word</span>
<span class="comment">// boundaries. And of course, the match position is reported relative</span>
<span class="comment">// to the sub-slice as well, which means we get `0..3` instead of</span>
<span class="comment">// `3..6`.</span>
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Match::must</span>(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>));
<span class="ident">re</span>.<span class="ident">search</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="kw-2">&amp;</span><span class="ident">Input::new</span>(<span class="kw-2">&amp;</span><span class="ident">haystack</span>[<span class="number">3</span>..<span class="number">6</span>]), <span class="kw-2">&amp;mut</span> <span class="ident">caps</span>);
<span class="macro">assert_eq!</span>(<span class="ident">expected</span>, <span class="ident">caps</span>.<span class="ident">get_match</span>());

<span class="comment">// But if we provide the bounds of the search within the context of the</span>
<span class="comment">// entire haystack, then the search can take the surrounding context</span>
<span class="comment">// into account. (And if we did find a match, it would be reported</span>
<span class="comment">// as a valid offset into `haystack` instead of its sub-slice.)</span>
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="ident">Input::new</span>(<span class="ident">haystack</span>).<span class="ident">range</span>(<span class="number">3</span>..<span class="number">6</span>);
<span class="ident">re</span>.<span class="ident">search</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="kw-2">&amp;</span><span class="ident">input</span>, <span class="kw-2">&amp;mut</span> <span class="ident">caps</span>);
<span class="macro">assert_eq!</span>(<span class="ident">expected</span>, <span class="ident">caps</span>.<span class="ident">get_match</span>());
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.search_slots" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#1091-1132">source</a></span><a href="#method.search_slots" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.search_slots" class="fnname">search_slots</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;input: &amp;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;slots: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;mut [</a><a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../util/primitives/struct.NonMaxUsize.html" title="struct regex_automata::util::primitives::NonMaxUsize">NonMaxUsize</a>&gt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a leftmost forward search and writes the spans of capturing
groups that participated in a match into the provided <code>slots</code>, and
returns the matching pattern ID. The contents of the slots for patterns
other than the matching pattern are unspecified. If no match was found,
then <code>None</code> is returned and the contents of <code>slots</code> is unspecified.</p>
<p>This is like <a href="struct.PikeVM.html#method.search" title="PikeVM::search"><code>PikeVM::search</code></a>, but it accepts a raw slots slice
instead of a <code>Captures</code> value. This is useful in contexts where you
don’t want or need to allocate a <code>Captures</code>.</p>
<p>It is legal to pass <em>any</em> number of slots to this routine. If the regex
engine would otherwise write a slot offset that doesn’t fit in the
provided slice, then it is simply skipped. In general though, there are
usually three slice lengths you might want to use:</p>
<ul>
<li>An empty slice, if you only care about which pattern matched.</li>
<li>A slice with
<a href="../struct.NFA.html#method.pattern_len"><code>pattern_len() * 2</code></a>
slots, if you only care about the overall match spans for each matching
pattern.</li>
<li>A slice with
<a href="../../../util/captures/struct.GroupInfo.html#method.slot_len"><code>slot_len()</code></a> slots, which
permits recording match offsets for every capturing group in every
pattern.</li>
</ul>
<h5 id="example-15"><a href="#example-15">Example</a></h5>
<p>This example shows how to find the overall match offsets in a
multi-pattern search without allocating a <code>Captures</code> value. Indeed, we
can put our slots right on the stack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">nfa::thompson::pikevm::PikeVM</span>, <span class="ident">PatternID</span>, <span class="ident">Input</span>};

<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::new_many</span>(<span class="kw-2">&amp;</span>[
    <span class="string">r&quot;\pL+&quot;</span>,
    <span class="string">r&quot;\d+&quot;</span>,
])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();
<span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="ident">Input::new</span>(<span class="string">&quot;!@#123&quot;</span>);

<span class="comment">// We only care about the overall match offsets here, so we just</span>
<span class="comment">// allocate two slots for each pattern. Each slot records the start</span>
<span class="comment">// and end of the match.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slots</span> <span class="op">=</span> [<span class="prelude-val">None</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">pid</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">search_slots</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="kw-2">&amp;</span><span class="ident">input</span>, <span class="kw-2">&amp;mut</span> <span class="ident">slots</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="ident">PatternID::must</span>(<span class="number">1</span>)), <span class="ident">pid</span>);

<span class="comment">// The overall match offsets are always at &#39;pid * 2&#39; and &#39;pid * 2 + 1&#39;.</span>
<span class="comment">// See &#39;GroupInfo&#39; for more details on the mapping between groups and</span>
<span class="comment">// slot indices.</span>
<span class="kw">let</span> <span class="ident">slot_start</span> <span class="op">=</span> <span class="ident">pid</span>.<span class="ident">unwrap</span>().<span class="ident">as_usize</span>() <span class="op">*</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">slot_end</span> <span class="op">=</span> <span class="ident">slot_start</span> <span class="op">+</span> <span class="number">1</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="ident">slots</span>[<span class="ident">slot_start</span>].<span class="ident">map</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="ident">s</span>.<span class="ident">get</span>()));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">6</span>), <span class="ident">slots</span>[<span class="ident">slot_end</span>].<span class="ident">map</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="ident">s</span>.<span class="ident">get</span>()));
</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.which_overlapping_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#1208-1215">source</a></span><a href="#method.which_overlapping_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.which_overlapping_matches" class="fnname">which_overlapping_matches</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cache: &amp;mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::nfa::thompson::pikevm::Cache">Cache</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;input: &amp;<a class="struct" href="../../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;patset: &amp;mut <a class="struct" href="../../../struct.PatternSet.html" title="struct regex_automata::PatternSet">PatternSet</a><br>)</h4></section></summary><div class="docblock"><p>Writes the set of patterns that match anywhere in the given search
configuration to <code>patset</code>. If multiple patterns match at the same
position and this <code>PikeVM</code> was configured with <a href="../../../enum.MatchKind.html#variant.All" title="MatchKind::All"><code>MatchKind::All</code></a>
semantics, then all matching patterns are written to the given set.</p>
<p>Unless all of the patterns in this <code>PikeVM</code> are anchored, then
generally speaking, this will visit every byte in the haystack.</p>
<p>This search routine <em>does not</em> clear the pattern set. This gives some
flexibility to the caller (e.g., running multiple searches with the
same pattern set), but does make the API bug-prone if you’re reusing
the same pattern set for multiple searches but intended them to be
independent.</p>
<p>If a pattern ID matched but the given <code>PatternSet</code> does not have
sufficient capacity to store it, then it is not inserted and silently
dropped.</p>
<h5 id="example-16"><a href="#example-16">Example</a></h5>
<p>This example shows how to find all matching patterns in a haystack,
even when some patterns match at the same position as other patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{
    <span class="ident">nfa::thompson::pikevm::PikeVM</span>,
    <span class="ident">Input</span>, <span class="ident">MatchKind</span>, <span class="ident">PatternSet</span>,
};

<span class="kw">let</span> <span class="ident">patterns</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[
    <span class="string">r&quot;\w+&quot;</span>, <span class="string">r&quot;\d+&quot;</span>, <span class="string">r&quot;\pL+&quot;</span>, <span class="string">r&quot;foo&quot;</span>, <span class="string">r&quot;bar&quot;</span>, <span class="string">r&quot;barfoo&quot;</span>, <span class="string">r&quot;foobar&quot;</span>,
];
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">PikeVM::builder</span>()
    .<span class="ident">configure</span>(<span class="ident">PikeVM::config</span>().<span class="ident">match_kind</span>(<span class="ident">MatchKind::All</span>))
    .<span class="ident">build_many</span>(<span class="ident">patterns</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">create_cache</span>();

<span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="ident">Input::new</span>(<span class="string">&quot;foobar&quot;</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">patset</span> <span class="op">=</span> <span class="ident">PatternSet::new</span>(<span class="ident">re</span>.<span class="ident">pattern_len</span>());
<span class="ident">re</span>.<span class="ident">which_overlapping_matches</span>(<span class="kw-2">&amp;mut</span> <span class="ident">cache</span>, <span class="kw-2">&amp;</span><span class="ident">input</span>, <span class="kw-2">&amp;mut</span> <span class="ident">patset</span>);
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>];
<span class="kw">let</span> <span class="ident">got</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">patset</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="ident">p</span>.<span class="ident">as_usize</span>()).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">expected</span>, <span class="ident">got</span>);
</code></pre></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h4></section></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/clone.rs.html#130">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../../../src/regex_automata/nfa/thompson/pikevm.rs.html#386">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.PikeVM.html" title="struct regex_automata::nfa::thompson::pikevm::PikeVM">PikeVM</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#553-558">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#555">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#537-548">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#545">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#84-96">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#89">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#93">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#594-603">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#600">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#579-588">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#585">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="regex_automata" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>